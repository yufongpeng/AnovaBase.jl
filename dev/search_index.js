var documenterSearchIndex = {"docs":
[{"location":"AnovaFixedEffectModels/#AnovaFixedEffectModels.jl","page":"AnovaFixedEffectModels.jl","title":"AnovaFixedEffectModels.jl","text":"","category":"section"},{"location":"AnovaFixedEffectModels/#AnovaBase.anova-Tuple{Type{<:GoodnessOfFit}, Vararg{FixedEffectModel}}","page":"AnovaFixedEffectModels.jl","title":"AnovaBase.anova","text":"anova(lfemodels...; test::Type{<: GoodnessOfFit})\nanova(anovamodel; test::Type{<: GoodnessOfFit})\nanova(test::Type{<: GoodnessOfFit}, lfemodels...; keyword_arguments...)\nanova(test::Type{<: GoodnessOfFit}, anovamodel; keyword_arguments...)\n\nAnalysis of variance.\n\nReturn AnovaResult{M, test, N}. See AnovaResult for details.\n\nArguments\n\nlfemodels: model objects\nFixedEffectModel fitted by AnovaFixedEffectModels.lfe or FixedEffectModels.reg.\nIf mutiple models are provided, they should be nested and the last one is the most complex.\nanovamodel: wrapped model objects; FullModel, NestedModels, and MixedAovModels.\ntest: test statistics for goodness of fit. Only FTest is available now.\n\nOther keyword arguments\n\nWhen one model is provided:  \ntype specifies type of anova. Default value is 1.\nWhen multiple models are provided:  \ncheck: allows to check if models are nested. Defalut value is true. Some checkers are not implemented now.\n\nnote: Note\nFor fitting new models and conducting anova at the same time, see anova_lfe for FixedEffectModel.\n\n\n\n\n\n","category":"method"},{"location":"AnovaFixedEffectModels/#AnovaFixedEffectModels.anova_lfe","page":"AnovaFixedEffectModels.jl","title":"AnovaFixedEffectModels.anova_lfe","text":"anova_lfe(f::FormulaTerm, tbl, vcov::CovarianceEstimator = Vcov.simple(); \n        test::Type{<: GoodnessOfFit} = FTest, keyword_arguments...)\nanova_lfe(test::Type{<: GoodnessOfFit}, f::FormulaTerm, tbl, vcov::CovarianceEstimator = Vcov.simple(); keyword_arguments...)\n\nANOVA for fixed-effect linear regression.\n\nvcov: estimator of covariance matrix.\ntype: type of anova (1, 2 or 3). Default value is 1.\n\nanova_lfe generates a FixedEffectModel for FTest, and multiple models for LRT.\n\n\n\n\n\n","category":"function"},{"location":"AnovaFixedEffectModels/#AnovaBase.nestedmodels-Tuple{FixedEffectModel}","page":"AnovaFixedEffectModels.jl","title":"AnovaBase.nestedmodels","text":"nestedmodels(model; keyword_arguments...)\nnestedmodels(model_type, formula, data; keyword_arguments...)\n\nCreate nested models NestedModels from a model or model_type, formula and data.\n\n\n\n\n\n","category":"method"},{"location":"AnovaFixedEffectModels/#AnovaFixedEffectModels.lfe","page":"AnovaFixedEffectModels.jl","title":"AnovaFixedEffectModels.lfe","text":"lfe(formula::FormulaTerm, df, vcov::CovarianceEstimator = Vcov.simple(); kwargs...)\n\nA GLM-styled function to fit a fixed-effect model. \n\n\n\n\n\n","category":"function"},{"location":"Algorithm_AnovaFixedEffectModels/#AnovaFixedEffectModels","page":"AnovaFixedEffectModels","title":"AnovaFixedEffectModels","text":"Define a vector of models mathbfM and the corresponding base models mathbfB\n\nbeginaligned\n    mathbfM = (M_1  M_n)\n    mathbfB = (B_1  B_n)\nendaligned\n\nwhere M_1 is the simplest model with fixed effects and M_n is the most complex model.\n\nWhen m models, (M_1  M_m), are given, mathbfM = (M_2  M_m), mathbfB = (M_1  M_m-1). \n\nWhen one model is given, n is the number of predictors except for the predictors used in the simplest model. The mathbf M and mathbf B depends on the type of ANOVA.\n\nLet m, the number of columns of M_n's model matrix; l, the number of predictors of M_n. \n\nDefine two sets, mathcalC = x in mathbbN  1 leq x leq m, the index of columns and mathcalP = x in mathbbN  1 leq x leq l, the index of predictors.\n\nA map id_X mathcalC mapsto mathcalP maps the index of columns into the corresponding predictor sequentially, i.e., \n\nbeginaligned\n    forall i in mathcalC id_X(i) = k implies itextth column text is a level of  ktextth predictor\n    forall i j in mathcalC i lt j implies id_X(i) leq id_X(j)\nendaligned\n\nThe included predictors of M_j and B_j are mathcalM_j subset mathcalP,  mathcalB_j subset mathcalP, respectively.\n\nWe can define a vector of index sets for each model, and calulate degrees of freedom (dof) of each predictor\n\nbeginaligned\n    mathbfI = (I_1  I_n)\n    mathbfdf = (n(I_1)  n(I_n))\nendaligned\n\nwhere forall i in I_k id_X(i) in mathcalM_ksetminus mathcalB_k, and n(I) is the size of I.\n\nThe explained deviance of each predictor is the difference of mathbfD and mathbfS\n\nmathbfE = mathbfD - mathbfS\n\nThe mean explained deviance epsilon_i^2 is therefore\n\nepsilon_i^2 = fracE_idf_i\n\nThe mean residual deviance sigma^2 \n\nsigma^2 =fracD_ndf_r\n\nwhere D_n is the residual sum of squares of M_n; df_r is the degrees of freedom of the residuals, i.e. df_r = nob - n(mathcalC), where nob is number of observations.","category":"section"},{"location":"Algorithm_AnovaFixedEffectModels/#F-test","page":"AnovaFixedEffectModels","title":"F-test","text":"F-value is a vector\n\nmathbfF sim mathcalF_mathbfdf df_r\n\nwhere \n\nF_i = fracepsilon_i^2sigma^2\n\nFor a single model, F-value is computed directly by the variance-covariance matrix (boldsymbol Sigma) and the coefficients (boldsymbol beta) of the model, the deviance is calculated backward; each M_j corresponds to a predictor p_j, i.e. id_XI_j = j.","category":"section"},{"location":"Algorithm_AnovaFixedEffectModels/#Type-I","page":"AnovaFixedEffectModels","title":"Type I","text":"Predictors are sequentially added to the null model with fixed effects B_1, i.e., \n\nbeginaligned\n    forall i j in x in mathbbN  1leq xleq n i  j implies (mathcalB_i subset mathcalB_j) land (mathcalM_i subset mathcalM_j)\n    mathcalM_i = mathcalB_i cup p_i\n    mathcalB_i+1 = mathcalM_i\nendaligned\n\nCalculate F-value by the the upper factor of Cholesky factorization of boldsymbol Sigma^-1 and multiplying with boldsymbol beta: \n\nbeginaligned\n    boldsymbolSigma^-1 = mathbfLU\n    boldsymboleta = mathbfUboldsymbolbeta\n    F_j = fracsum_k in I_jeta_k^2df_j\nendaligned","category":"section"},{"location":"Algorithm_AnovaFixedEffectModels/#Type-II","page":"AnovaFixedEffectModels","title":"Type II","text":"The included predictors are defined as follows,\n\nbeginaligned\n    mathcalB_j = k in mathcalP  k text is not an interaction term of p_j text and other terms\n    mathcalM_j = mathcalB_j cup p_j\nendaligned\n\nDefine two vectors of index sets mathbf J and mathbf K where \n\nbeginaligned\n    J_j = i in mathcalC  id_X(i) text is an interaction term of p_j text and other terms\n    K_j = J_j cup I_j\nendaligned\n\nAnd F-value is\n\nF_j = fracboldsymbolbeta_K_j^T boldsymbolSigma_K_j K_j^-1 boldsymbolbeta_K_j - boldsymbolbeta_J_j^T boldsymbolSigma_J_j J_j^-1 boldsymbolbeta_J_jdf_j","category":"section"},{"location":"Algorithm_AnovaFixedEffectModels/#Type-III","page":"AnovaFixedEffectModels","title":"Type III","text":"All elements of mathbfM are the most complex model, and the base models are models without each predictors, i.e.\n\nbeginaligned\n    mathcalM_j = mathcalP\n    mathcalB_j = mathcalP setminus p_j\nendaligned\n\nAnd F-value is\n\nF_j = fracboldsymbolbeta_I_j^T boldsymbolSigma_I_j I_j^-1 boldsymbolbeta_I_jdf_j","category":"section"},{"location":"Algorithm_AnovaFixedEffectModels/#LRT","page":"AnovaFixedEffectModels","title":"LRT","text":"The likelihood ratio is a vector\n\nbeginaligned \n    mathbfL = fracmathbfEsigma^2\n    mathbfL sim chi^2_mathbfdf\nendaligned","category":"section"},{"location":"AnovaBase/#AnovaBase.jl","page":"AnovaBase.jl","title":"AnovaBase.jl","text":"","category":"section"},{"location":"AnovaBase/#Models","page":"AnovaBase.jl","title":"Models","text":"","category":"section"},{"location":"AnovaBase/#ANOVA","page":"AnovaBase.jl","title":"ANOVA","text":"","category":"section"},{"location":"AnovaBase/#Attributes","page":"AnovaBase.jl","title":"Attributes","text":"","category":"section"},{"location":"AnovaBase/#Goodness-of-fit","page":"AnovaBase.jl","title":"Goodness of fit","text":"","category":"section"},{"location":"AnovaBase/#Other-interface","page":"AnovaBase.jl","title":"Other interface","text":"","category":"section"},{"location":"AnovaBase/#Developer-utility","page":"AnovaBase.jl","title":"Developer utility","text":"","category":"section"},{"location":"AnovaBase/#AnovaBase.AnovaModel","page":"AnovaBase.jl","title":"AnovaBase.AnovaModel","text":"abstract type AnovaModel{M, N} end\n\nAn abstract type as super type of any models for ANOVA.\n\n\n\n\n\n","category":"type"},{"location":"AnovaBase/#AnovaBase.FullModel","page":"AnovaBase.jl","title":"AnovaBase.FullModel","text":"FullModel{M, N} <: AnovaModel{M, N}\n\nA wrapper of a regression model for conducting ANOVA.\n\nM is a type of regression model.\nN is the number of predictors.\n\nFields\n\nmodel: a regression model.\npred_id: the index of terms included in ANOVA. The source iterable can be obtained by predictors(model). This value may depend on type for certain model, e.g. type 1 ANOVA for a gamma regression model with inverse link.\ntype: type of ANOVA, either 1, 2 or 3.\n\nConstructor\n\nFullModel(model::RegressionModel, type::Int, null::Bool, test_intercept::Bool)\n\nmodel: a regression model.\ntype: type of ANOVA, either 1, 2 or 3.\nnull: whether y ~ 0 is allowed.\ntest_intercept: whether intercept is going to be tested.\n\n\n\n\n\n","category":"type"},{"location":"AnovaBase/#AnovaBase.NestedModels","page":"AnovaBase.jl","title":"AnovaBase.NestedModels","text":"NestedModels{M, N} <: AnovaModel{M, N}\n\nA wrapper of nested models of the same type for conducting ANOVA.\n\nM is a type of regression model.\nN is the number of models.\n\nFields\n\nmodel: a tuple of models.\n\nConstructors\n\nNestedModels(model::Vararg{M, N}) where {M, N}\nNestedModels(model::NTuple{N, M}) where {M, N}\n\n\n\n\n\n","category":"type"},{"location":"AnovaBase/#AnovaBase.MixedAovModels","page":"AnovaBase.jl","title":"AnovaBase.MixedAovModels","text":"MixedAovModels{M, N} <: AnovaModel{M, N}\n\nA wrapper of nested models of multiple types for conducting ANOVA.\n\nM is a union type of regression models.\nN is the number of models.\n\nFields\n\nmodel: a tuple of models.\n\nConstructors\n\nMixedAovModels{M}(model...) where M \nMixedAovModels{M}(model::T) where {M, T <: Tuple}\n\n\n\n\n\n","category":"type"},{"location":"AnovaBase/#AnovaBase.MultiAovModels","page":"AnovaBase.jl","title":"AnovaBase.MultiAovModels","text":"const MultiAovModels{M, N} = Union{NestedModels{M, N}, MixedAovModels{M, N}} where {M, N}\n\nWrappers of mutiple models.\n\n\n\n\n\n","category":"type"},{"location":"AnovaBase/#AnovaBase.MultiAovModels-Tuple{NTuple{N, T} where {N, T}}","page":"AnovaBase.jl","title":"AnovaBase.MultiAovModels","text":"MultiAovModels(model::NTuple{N, M}) where {M, N} -> NestedModels{M, N}\nMultiAovModels(model::Vararg{M, N}) where {M, N} -> NestedModels{M, N}\nMultiAovModels(model::T) where {T <: Tuple}      -> MixedAovModels\nMultiAovModels(model...)                         -> MixedAovModels\n\nConstruct NestedModels or MixedAovModels based on model types.\n\n\n\n\n\n","category":"method"},{"location":"AnovaBase/#AnovaBase.nestedmodels-Tuple{RegressionModel}","page":"AnovaBase.jl","title":"AnovaBase.nestedmodels","text":"nestedmodels(model; keyword_arguments...)\nnestedmodels(model_type, formula, data; keyword_arguments...)\n\nCreate nested models NestedModels from a model or model_type, formula and data.\n\n\n\n\n\n","category":"method"},{"location":"AnovaBase/#AnovaBase.AnovaResult","page":"AnovaBase.jl","title":"AnovaBase.AnovaResult","text":"AnovaResult{M, T, N}\n\nReturned object of anova.\n\nM is NestedModels or FullModel.\nT is a subtype of GoodnessOfFit; either FTest or LRT.\nN is the length of parameters.\n\nFields\n\nanovamodel: NestedModels, MixedAovModels, or FullModel.\ndof: degrees of freedom of models or predictors.\ndeviance: deviance(s) for calculating test statistics. See deviance for more details.\nteststat: value(s) of test statiscics.\npval: p-value(s) of test statiscics.\notherstat: NamedTuple contained extra statistics.\n\nConstructor\n\nAnovaResult(\n        anovamodel::M,\n        ::Type{T},\n        dof::NTuple{N, Int},\n        deviance::NTuple{N, Float64},\n        teststat::NTuple{N, Float64},\n        pval::NTuple{N, Float64},\n        otherstat::NamedTuple\n) where {N, M <: AnovaModel{<: RegressionModel, N}, T <: GoodnessOfFit}\n\n\n\n\n\n","category":"type"},{"location":"AnovaBase/#AnovaBase.anova-Tuple{Type{<:GoodnessOfFit}, AnovaModel}","page":"AnovaBase.jl","title":"AnovaBase.anova","text":"anova(Test::Type{<: GoodnessOfFit}, anovamodel; keyword_arguments...)\nanova(models...; test::Type{<: GoodnessOfFit}, keyword_arguments...)\nanova(Test::Type{<: GoodnessOfFit}, model; keyword_arguments...)\nanova(Test::Type{<: GoodnessOfFit}, models...; keyword_arguments...)\n\nAnalysis of variance.\n\nReturn AnovaResult{M, Test, N}. See AnovaResult for details.\n\nanovamodel: a AnovaModel.\nmodel(s): RegressionModel(s). If mutiple models are provided, they should be nested, fitted with the same data and the last one is the most complex.\nTest: test statistics for goodness of fit. Available tests are LikelihoodRatioTest (LRT) and FTest.\n\n\n\n\n\n","category":"method"},{"location":"AnovaBase/#AnovaBase.anova_test-Tuple{AnovaResult}","page":"AnovaBase.jl","title":"AnovaBase.anova_test","text":"anova_test(::AnovaResult)\n\nTest statiscics of anova. See AnovaResult for details.\n\n\n\n\n\n","category":"method"},{"location":"AnovaBase/#AnovaBase.anova_type-Tuple{AnovaResult}","page":"AnovaBase.jl","title":"AnovaBase.anova_type","text":"anova_type(aov::AnovaResult)\nanova_type(model::MultiAovModels)\nanova_type(model::FullModel)\n\nType of anova, either 1, 2 or 3.\n\n\n\n\n\n","category":"method"},{"location":"AnovaBase/#AnovaBase.pval-Tuple{AnovaResult}","page":"AnovaBase.jl","title":"AnovaBase.pval","text":"teststat(aov::AnovaResult)\n\nP-values of test statiscics of anova. See AnovaResult for details.\n\n\n\n\n\n","category":"method"},{"location":"AnovaBase/#AnovaBase.teststat-Tuple{AnovaResult}","page":"AnovaBase.jl","title":"AnovaBase.teststat","text":"teststat(aov::AnovaResult)\n\nValues of test statiscics of anova. See AnovaResult for details.\n\n\n\n\n\n","category":"method"},{"location":"AnovaBase/#StatsAPI.deviance-Tuple{AnovaResult}","page":"AnovaBase.jl","title":"StatsAPI.deviance","text":"deviance(aov::AnovaResult)\n\nReturn the stored devaince. The value repressents different statistics for different models and tests.  It may be deviance, Δdeviance, -2loglikelihood or other measures of model performance.\n\n\n\n\n\n","category":"method"},{"location":"AnovaBase/#StatsAPI.dof-Tuple{AnovaResult}","page":"AnovaBase.jl","title":"StatsAPI.dof","text":"dof(aov::AnovaResult)\n\nDegrees of freedom of each models or predictors.\n\n\n\n\n\n","category":"method"},{"location":"AnovaBase/#StatsAPI.nobs-Tuple{AnovaResult}","page":"AnovaBase.jl","title":"StatsAPI.nobs","text":"nobs(aov::AnovaResult)\nnobs(aov::AnovaResult{<: MultiAovModels})\n\nNumber of observations.\n\n\n\n\n\n","category":"method"},{"location":"AnovaBase/#AnovaBase.GoodnessOfFit","page":"AnovaBase.jl","title":"AnovaBase.GoodnessOfFit","text":"abstract type GoodnessOfFit end\n\nAn abstract type as super type of all types of goodness of fit.\n\n\n\n\n\n","category":"type"},{"location":"AnovaBase/#AnovaBase.FTest","page":"AnovaBase.jl","title":"AnovaBase.FTest","text":"struct FTest <: GoodnessOfFit end\n\nType indicates conducting ANOVA by F-test. It can be the first argument or keyword argument test in anova function.\n\n\n\n\n\n","category":"type"},{"location":"AnovaBase/#AnovaBase.LikelihoodRatioTest","page":"AnovaBase.jl","title":"AnovaBase.LikelihoodRatioTest","text":"struct LikelihoodRatioTest <: GoodnessOfFit end\nconst LRT = LikelihoodRatioTest\n\nType indicates conducting ANOVA by likelihood-ratio test. It can be the first argument or keyword argument test in anova function.\n\n\n\n\n\n","category":"type"},{"location":"AnovaBase/#AnovaBase.canonicalgoodnessoffit","page":"AnovaBase.jl","title":"AnovaBase.canonicalgoodnessoffit","text":"canonicalgoodnessoffit(::FixDispDist) = LRT\ncanonicalgoodnessoffit(::UnivariateDistribution) = FTest\n\nconst FixDispDist = Union{Bernoulli, Binomial, Poisson}\n\nReturn LRT if the distribution has a fixed dispersion; otherwise, FTest.\n\n\n\n\n\n","category":"function"},{"location":"AnovaBase/#AnovaBase.ftest_nested","page":"AnovaBase.jl","title":"AnovaBase.ftest_nested","text":"ftest_nested(models::MultiAovModels{M, N}, df, dfr, dev, σ²) where {M <: RegressionModel, N}\n\nCalculate F-statiscics and p-values based on given parameters.\n\nmodels: nested models \ndf: degrees of freedoms of each models\ndfr: degrees of freedom of residuals of each models\ndev: deviances of each models, i.e. unit deviance\nσ²: squared dispersion of each models\n\nF-statiscic is (devᵢ - devᵢ₋₁) / (dfᵢ₋₁ - dfᵢ) / σ² for the ith predictor.\n\n\n\n\n\n","category":"function"},{"location":"AnovaBase/#AnovaBase.lrt_nested","page":"AnovaBase.jl","title":"AnovaBase.lrt_nested","text":"lrt_nested(models::MultiAovModels{M, N}, df, dev, σ²) where {M <: RegressionModel, N}\n\nCalculate likelihood ratio and p-values based on given parameters.\n\nmodels: nested models \ndf: degrees of freedom of each models\ndev: deviances of each models, i.e. unit deviance\nσ²: squared dispersion of each models\n\nThe likelihood ratio of the ith predictor is LRᵢ = (devᵢ - devᵢ₋₁) / σ².\n\nIf dev is alternatively -2loglikelihood, σ² should be set to 1.\n\n\n\n\n\n","category":"function"},{"location":"AnovaBase/#StatsAPI.dof_residual-Tuple{AnovaResult}","page":"AnovaBase.jl","title":"StatsAPI.dof_residual","text":"dof_residual(aov::AnovaResult)    \ndof_residual(aov::AnovaResult{<: MultiAovModels})\n\nDegrees of freedom of residuals.\n\nBy default, it applies dof_aovres to models in aov.anovamodel.\n\n\n\n\n\n","category":"method"},{"location":"AnovaBase/#AnovaBase.dof_aovres-Tuple{RegressionModel}","page":"AnovaBase.jl","title":"AnovaBase.dof_aovres","text":"dof_aovres(m::RegressionModel)\n\nDegrees of freedom of residuals for ANOVA.\n\nBy default, it calls dof_residual.\n\n\n\n\n\n","category":"method"},{"location":"AnovaBase/#AnovaBase.dof_aov-Tuple{RegressionModel}","page":"AnovaBase.jl","title":"AnovaBase.dof_aov","text":"dof_aov(m::RegressionModel)\n\nDegrees of freedom of model for ANOVA.\n\nBy default, it calls dof.\n\n\n\n\n\n","category":"method"},{"location":"AnovaBase/#AnovaBase.formula_aov-Tuple{RegressionModel}","page":"AnovaBase.jl","title":"AnovaBase.formula_aov","text":"formula_aov(m::RegressionModel)\n\nFormula of model for ANOVA.\n\nBy default, it calls formula.\n\n\n\n\n\n","category":"method"},{"location":"AnovaBase/#AnovaBase.predictors-Tuple{RegressionModel}","page":"AnovaBase.jl","title":"AnovaBase.predictors","text":"predictors(model::RegressionModel)\npredictors(anovamodel::FullModel)\n\nReturn a tuple of Terms which are predictors of the model or anovamodel. \n\nBy default, it returns formula_aov(model).rhs.terms; if the formula has special structures, this function should be overloaded.\n\n\n\n\n\n","category":"method"},{"location":"AnovaBase/#AnovaBase.anovatable-Tuple{AnovaResult{<:FullModel}}","page":"AnovaBase.jl","title":"AnovaBase.anovatable","text":"anovatable(aov::AnovaResult{<: FullModel, Test}; rownames = prednames(aov))\nanovatable(aov::AnovaResult{<: MultiAovModels, Test}; rownames = string.(1:N))\nanovatable(aov::AnovaResult{<: MultiAovModels, FTest, N}; rownames = string.(1:N)) where N\nanovatable(aov::AnovaResult{<: MultiAovModels, LRT, N}; rownames = string.(1:N)) where N\n\nReturn a table with coefficients and related statistics of ANOVA.\n\nWhen displaying aov in repl, rownames will be prednames(aov) for FullModel and string.(1:N) for MultiAovModels. \n\nFor MultiAovModels, there are two default methods for FTest and LRT; users can also define new methods dispatching on ::AnovaResult{NestedModels{M}} or ::AnovaResult{MixedAovModels{M}} where M is a model type. \n\nFor FullModel, no default api is implemented.\n\nThe returned AnovaTable object implements the Tables.jl interface, and can be   converted e.g. to a DataFrame via using DataFrames; DataFrame(anovatable(aov)).\n\n\n\n\n\n","category":"method"},{"location":"AnovaBase/#AnovaBase.dof_asgn","page":"AnovaBase.jl","title":"AnovaBase.dof_asgn","text":"dof_asgn(assign::Vector{Int})\n\nCalculate degrees of freedom of each predictors. assign can be obtained by StatsModels.asgn(f::FormulaTerm). For a given trm::RegressionModel, it is as same as trm.mm.assign.\n\nThe index of the output matches values in the orinal assign. If any index value is not in assign, the default is 0.\n\nExamples\n\njulia> dof_asgn([1, 2, 2, 3, 3, 3])\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> dof_asgn([2, 2, 3, 3, 3])\n3-element Vector{Int64}:\n 0\n 2\n 3\n\n\n\n\n\n\n","category":"function"},{"location":"AnovaBase/#AnovaBase.prednames","page":"AnovaBase.jl","title":"AnovaBase.prednames","text":"prednames(term)\n\nReturn the name(s) of predictor(s). Return value is either a String, an iterable of Strings or nothing.\n\nExamples\n\njulia> iris = dataset(\"datasets\", \"iris\");\n\njulia> f = formula(lm(@formula(log(SepalLength) ~ SepalWidth + PetalLength * PetalWidth), iris))\nFormulaTerm\nResponse:\n  (SepalLength)->log(SepalLength)\nPredictors:\n  1\n  SepalWidth(continuous)\n  PetalLength(continuous)\n  PetalWidth(continuous)\n  PetalLength(continuous) & PetalWidth(continuous)\n\njulia> prednames(f)\n[\"(Intercept)\", \"SepalWidth\", \"PetalLength\", \"PetalWidth\", \"PetalLength & PetalWidth\"]\n\njulia> prednames(InterceptTerm{false}())\n\n\n\n\n\n\n\nprednames(aov::AnovaResult)\nprednames(anovamodel::FullModel) \nprednames(anovamodel::MultiAovModels)\nprednames(model)\n\nReturn the name of predictors as a vector of strings. When there are multiple models, return value is nothing.\n\n\n\n\n\n","category":"function"},{"location":"AnovaBase/#AnovaBase.any_not_aliased_with_1","page":"AnovaBase.jl","title":"AnovaBase.any_not_aliased_with_1","text":"any_not_aliased_with_1(terms)\n\nReturn true if there are any terms not aliased with the intercept, e.g. ContinuousTerm or FunctionTerm.\n\nTerms without schema are considered aliased with the intercept.\n\n\n\n\n\n","category":"function"},{"location":"AnovaBase/#AnovaBase.getterms","page":"AnovaBase.jl","title":"AnovaBase.getterms","text":"getterms(term)\n\nReturn the symbol of term(s) as a vector of Expr or Symbol.\n\nExamples\n\njulia> iris = dataset(\"datasets\", \"iris\");\n\njulia> f = formula(lm(@formula(log(SepalLength) ~ Species + PetalLength * PetalWidth), iris))\nFormulaTerm\nResponse:\n  (SepalLength)->log(SepalLength)\nPredictors:\n  1\n  Species(DummyCoding:3→2)\n  PetalLength(continuous)\n  PetalWidth(continuous)\n  PetalLength(continuous) & PetalWidth(continuous)\n\njulia> getterms(f)\n(Expr[:(log(SepalLength))], [:Species, :PetalLength, :PetalWidth])\n\njulia> getterms(InterceptTerm{true}())\nSymbol[]\n\n\n\n\n\n\n","category":"function"},{"location":"AnovaBase/#AnovaBase.isinteract","page":"AnovaBase.jl","title":"AnovaBase.isinteract","text":"isinteract(f::Union{MatrixTerm, TupleTerm}, id1::Int, id2::Int)\n\nDetermine if f[id2] is an interaction term of f[id1] and other terms.\n\nExamples\n\njulia> iris = dataset(\"datasets\", \"iris\");\n\njulia> f = formula(lm(@formula(log(SepalLength) ~ Species + PetalLength * PetalWidth), iris))\nFormulaTerm\nResponse:\n  (SepalLength)->log(SepalLength)\nPredictors:\n  1\n  Species(DummyCoding:3→2)\n  PetalLength(continuous)\n  PetalWidth(continuous)\n  PetalLength(continuous) & PetalWidth(continuous)\n\njulia> isinteract(f.rhs, 1, 2)\ntrue\n\njulia> isinteract(f.rhs, 3, 4)\nfalse\n\njulia> isinteract(f.rhs, 4, 5)\ntrue\n\n\n\n\n\n\n","category":"function"},{"location":"AnovaBase/#AnovaBase.select_super_interaction","page":"AnovaBase.jl","title":"AnovaBase.select_super_interaction","text":"select_super_interaction(f::Union{MatrixTerm, TupleTerm}, id::Int)\nselect_sub_interaction(f::Union{MatrixTerm, TupleTerm}, id::Int)\nselect_not_super_interaction(f::Union{MatrixTerm, TupleTerm}, id::Int)\nselect_not_sub_interaction(f::Union{MatrixTerm, TupleTerm}, id::Int)\n\nReturn a set of index of f, which\n\nreturned terms are interaction terms of f[id] and other terms.\nf[id] is an interaction term of returned terms and other terms.\nreturned terms not interaction terms of f[id] and other terms.\nf[id] is not interaction term of returned terms and other terms.\n\nExamples\n\njulia> iris = dataset(\"datasets\", \"iris\");\n\njulia> f = formula(lm(@formula(log(SepalLength) ~ Species + PetalLength * PetalWidth), iris))\nFormulaTerm\nResponse:\n  (SepalLength)->log(SepalLength)\nPredictors:\n  1\n  Species(DummyCoding:3→2)\n  PetalLength(continuous)\n  PetalWidth(continuous)\n  PetalLength(continuous) & PetalWidth(continuous)\n\njulia> select_super_interaction(f.rhs, 3)\nSet{Int64} with 2 elements:\n  5\n  3\n\njulia> select_sub_interaction(f.rhs, 3)\nSet{Int64} with 2 elements:\n  3\n  1\n\njulia> select_not_super_interaction(f.rhs, 3)\nSet{Int64} with 3 elements:\n  4\n  2\n  1\n\njulia> select_not_sub_interaction(f.rhs, 3)\nSet{Int64} with 3 elements:\n  5\n  4\n  2\n\n\n\n\n\n\n","category":"function"},{"location":"AnovaBase/#AnovaBase.select_sub_interaction","page":"AnovaBase.jl","title":"AnovaBase.select_sub_interaction","text":"select_super_interaction(f::Union{MatrixTerm, TupleTerm}, id::Int)\nselect_sub_interaction(f::Union{MatrixTerm, TupleTerm}, id::Int)\nselect_not_super_interaction(f::Union{MatrixTerm, TupleTerm}, id::Int)\nselect_not_sub_interaction(f::Union{MatrixTerm, TupleTerm}, id::Int)\n\nReturn a set of index of f, which\n\nreturned terms are interaction terms of f[id] and other terms.\nf[id] is an interaction term of returned terms and other terms.\nreturned terms not interaction terms of f[id] and other terms.\nf[id] is not interaction term of returned terms and other terms.\n\nExamples\n\njulia> iris = dataset(\"datasets\", \"iris\");\n\njulia> f = formula(lm(@formula(log(SepalLength) ~ Species + PetalLength * PetalWidth), iris))\nFormulaTerm\nResponse:\n  (SepalLength)->log(SepalLength)\nPredictors:\n  1\n  Species(DummyCoding:3→2)\n  PetalLength(continuous)\n  PetalWidth(continuous)\n  PetalLength(continuous) & PetalWidth(continuous)\n\njulia> select_super_interaction(f.rhs, 3)\nSet{Int64} with 2 elements:\n  5\n  3\n\njulia> select_sub_interaction(f.rhs, 3)\nSet{Int64} with 2 elements:\n  3\n  1\n\njulia> select_not_super_interaction(f.rhs, 3)\nSet{Int64} with 3 elements:\n  4\n  2\n  1\n\njulia> select_not_sub_interaction(f.rhs, 3)\nSet{Int64} with 3 elements:\n  5\n  4\n  2\n\n\n\n\n\n\n","category":"function"},{"location":"AnovaBase/#AnovaBase.select_not_super_interaction","page":"AnovaBase.jl","title":"AnovaBase.select_not_super_interaction","text":"select_super_interaction(f::Union{MatrixTerm, TupleTerm}, id::Int)\nselect_sub_interaction(f::Union{MatrixTerm, TupleTerm}, id::Int)\nselect_not_super_interaction(f::Union{MatrixTerm, TupleTerm}, id::Int)\nselect_not_sub_interaction(f::Union{MatrixTerm, TupleTerm}, id::Int)\n\nReturn a set of index of f, which\n\nreturned terms are interaction terms of f[id] and other terms.\nf[id] is an interaction term of returned terms and other terms.\nreturned terms not interaction terms of f[id] and other terms.\nf[id] is not interaction term of returned terms and other terms.\n\nExamples\n\njulia> iris = dataset(\"datasets\", \"iris\");\n\njulia> f = formula(lm(@formula(log(SepalLength) ~ Species + PetalLength * PetalWidth), iris))\nFormulaTerm\nResponse:\n  (SepalLength)->log(SepalLength)\nPredictors:\n  1\n  Species(DummyCoding:3→2)\n  PetalLength(continuous)\n  PetalWidth(continuous)\n  PetalLength(continuous) & PetalWidth(continuous)\n\njulia> select_super_interaction(f.rhs, 3)\nSet{Int64} with 2 elements:\n  5\n  3\n\njulia> select_sub_interaction(f.rhs, 3)\nSet{Int64} with 2 elements:\n  3\n  1\n\njulia> select_not_super_interaction(f.rhs, 3)\nSet{Int64} with 3 elements:\n  4\n  2\n  1\n\njulia> select_not_sub_interaction(f.rhs, 3)\nSet{Int64} with 3 elements:\n  5\n  4\n  2\n\n\n\n\n\n\n","category":"function"},{"location":"AnovaBase/#AnovaBase.select_not_sub_interaction","page":"AnovaBase.jl","title":"AnovaBase.select_not_sub_interaction","text":"select_super_interaction(f::Union{MatrixTerm, TupleTerm}, id::Int)\nselect_sub_interaction(f::Union{MatrixTerm, TupleTerm}, id::Int)\nselect_not_super_interaction(f::Union{MatrixTerm, TupleTerm}, id::Int)\nselect_not_sub_interaction(f::Union{MatrixTerm, TupleTerm}, id::Int)\n\nReturn a set of index of f, which\n\nreturned terms are interaction terms of f[id] and other terms.\nf[id] is an interaction term of returned terms and other terms.\nreturned terms not interaction terms of f[id] and other terms.\nf[id] is not interaction term of returned terms and other terms.\n\nExamples\n\njulia> iris = dataset(\"datasets\", \"iris\");\n\njulia> f = formula(lm(@formula(log(SepalLength) ~ Species + PetalLength * PetalWidth), iris))\nFormulaTerm\nResponse:\n  (SepalLength)->log(SepalLength)\nPredictors:\n  1\n  Species(DummyCoding:3→2)\n  PetalLength(continuous)\n  PetalWidth(continuous)\n  PetalLength(continuous) & PetalWidth(continuous)\n\njulia> select_super_interaction(f.rhs, 3)\nSet{Int64} with 2 elements:\n  5\n  3\n\njulia> select_sub_interaction(f.rhs, 3)\nSet{Int64} with 2 elements:\n  3\n  1\n\njulia> select_not_super_interaction(f.rhs, 3)\nSet{Int64} with 3 elements:\n  4\n  2\n  1\n\njulia> select_not_sub_interaction(f.rhs, 3)\nSet{Int64} with 3 elements:\n  5\n  4\n  2\n\n\n\n\n\n\n","category":"function"},{"location":"AnovaBase/#AnovaBase.subformula","page":"AnovaBase.jl","title":"AnovaBase.subformula","text":"subformula(f::FormulaTerm, id; kwargs...)\nsubformula(lhs::AbstractTerm, rhs::MatrixTerm, id::Int; reschema::Bool = false)\nsubformula(lhs::AbstractTerm, rhs::MatrixTerm, id; reschema::Bool = false)\nsubformula(lhs::AbstractTerm, rhs::NTuple{N, AbstractTerm}, id::Int; rhs_id::Int = 1, reschema::Bool = false)\n\nCreate formula from existing lhs and rhs (or rhs[tuple_id]) truncated to 1:id or excluded collection id.  When id is 0, all terms in rhs (or rhs[tuple_id]) will be removed.\n\nIf reschema is true, all terms' schema will be removed.\n\nExamples\n\njulia> iris = dataset(\"datasets\", \"iris\");\n\njulia> f = formula(lm(@formula(log(SepalLength) ~ Species + PetalLength * PetalWidth), iris))\nFormulaTerm\nResponse:\n  (SepalLength)->log(SepalLength)\nPredictors:\n  1\n  Species(DummyCoding:3→2)\n  PetalLength(continuous)\n  PetalWidth(continuous)\n  PetalLength(continuous) & PetalWidth(continuous)\n\njulia> subformula(f, 2)\nFormulaTerm\nResponse:\n  (SepalLength)->log(SepalLength)\nPredictors:\n  1\n  Species(DummyCoding:3→2)\n\njulia> subformula(f, [3, 5]; reschema = true)\nFormulaTerm\nResponse:\n  (SepalLength)->log(SepalLength)\nPredictors:\n  1\n  Species(DummyCoding:3→2)\n  PetalWidth(unknown)\n\njulia> f = formula(fit(LinearMixedModel, @formula(SepalLength ~ SepalWidth + (SepalWidth|Species)), iris))\nFormulaTerm\nResponse:\n  SepalLength(continuous)\nPredictors:\n  1\n  SepalWidth(continuous)\n  (1 + SepalWidth | Species)\n\njulia> subformula(f, 0)\nFormulaTerm\nResponse:\n  SepalLength(continuous)\nPredictors:\n  0\n  (1 + SepalWidth | Species)\n\n\n\n\n\n\n","category":"function"},{"location":"AnovaBase/#AnovaBase.clear_schema","page":"AnovaBase.jl","title":"AnovaBase.clear_schema","text":"clear_schema(terms_with_schema) -> terms_without_schema\n\nClear any applied schema on terms.\n\n\n\n\n\n","category":"function"},{"location":"AnovaBase/#AnovaBase.extract_contrasts","page":"AnovaBase.jl","title":"AnovaBase.extract_contrasts","text":"extract_contrasts(f::FormulaTerm)\n\nExtract a dictionary of contrasts. The keys are symbols of term; the values are contrasts (AbstractContrasts).\n\n\n\n\n\n","category":"function"},{"location":"AnovaBase/#AnovaBase._diff","page":"AnovaBase.jl","title":"AnovaBase._diff","text":"_diff(t::NTuple)\n\nReturn a tuple of difference between adjacent elements of a tuple(later - former). \n\n\n\n\n\n","category":"function"},{"location":"AnovaBase/#AnovaBase._diffn","page":"AnovaBase.jl","title":"AnovaBase._diffn","text":"_diff(t::NTuple)\n\nReturn a tuple of difference between adjacent elements of a tuple(former - later). \n\n\n\n\n\n","category":"function"},{"location":"AnovaBase/#AnovaBase.AnovaTable","page":"AnovaBase.jl","title":"AnovaBase.AnovaTable","text":"AnovaTable\n\nA table with coefficients and related statistics of ANOVA. It is mostly modified from StatsBase.CoefTable.\n\nFields\n\ncols: values of each statiscics.\ncolnms: names of statiscics.\nrownms: names of each row.\npvalcol: the index of column repressenting p-value.\nteststatcol: the index of column representing test statiscics.\n\nConstructor\n\nAnovaTable(cols::Vector, colnms::Vector, rownms::Vector, pvalcol::Int = 0, teststatcol::Int = 0)\nAnovaTable(mat::Matrix, colnms::Vector, rownms::Vector, pvalcol::Int = 0, teststatcol::Int = 0)\n\n\n\n\n\n","category":"type"},{"location":"AnovaBase/#AnovaBase.testname","page":"AnovaBase.jl","title":"AnovaBase.testname","text":"testname(::Type{FTest}) = \"F test\"\ntestname(::Type{LRT}) = \"Likelihood-ratio test\"\n\nName of tests.\n\n\n\n\n\n","category":"function"},{"location":"Examples_MixedModels/#AnovaMixedModels","page":"AnovaMixedModels","title":"AnovaMixedModels","text":"The implementation of ANOVA for mixed-effects models is primarily based on MixedModels. The syntax is similar to anova for GLM.   \n\nusing AnovaMixedModels","category":"section"},{"location":"Examples_MixedModels/#Linear-mixed-effects-model","page":"AnovaMixedModels","title":"Linear mixed-effects model","text":"We get a dataset from R directly by RCall.\n\nR\"\"\"data(\"anxiety\", package = \"datarium\")\"\"\"\nanxiety = stack(rcopy(R\"anxiety\"), [:t1, :t2, :t3], [:id, :group], variable_name = :time, value_name = :score)\nanxiety = combine(anxiety, Not(:time), :time => ByRow(x->parse(Int, replace(String(x), \"t\"=>\"\"))) => :time)\n\nWe can fit a linear mixed-effects model first. \n\nlmm1 = lmm(@formula(score ~ group * time + (1|id)), anxiety)\nanova(lmm1)\n\nAlternatively, we can use anova_lmm. Like anova_lm, this function will fit and store a model; in this case, a LinearMixedModel fitted by Restricted maximum likelihood.\n\naov = anova_lmm(@formula(score ~ group * time + (1|id)), anxiety, type = 3)\n\naov.anovamodel.model.optsum.REML\n\nFor likeihood-ratio test, all submodels are fitted. The model should be fitted by maximum likelihood estimation.\n\nanova(LRT, lmm1)\n\nWhen comparing multiple mixed models, likelihood-ratio test is used by default.  It's also identical to StatsModels.lrtest and MixedModels.likelihoodratiotest.\n\nlmms = nestedmodels(lmm1)\nanova(lmms) # == anova(LRT, lmm1)\n\nMixedModels.likelihoodratiotest(lmms.model[2:end]...)\n\nComparing between LinearModel and LinearMixedModel is also available.\n\nlm1 = lm(@formula(score ~ group * time), anxiety)\nlmm2 = lmm(@formula(score ~ group * time + (group|id)), anxiety)\nanova(lm1, lmm1, lmm2)","category":"section"},{"location":"Examples_MixedModels/#Generalized-linear-mixed-effects-model","page":"AnovaMixedModels","title":"Generalized linear mixed-effects model","text":"The following is an example of generalized mixed model.\n\nR\"\"\"data(\"toenail\", package = \"HSAUR2\")\"\"\"\ntoenail = rcopy(R\"toenail\")\n\nglmm1 = glmm(@formula(outcome ~ visit + treatment + (1|patientID)), toenail, Binomial(), LogitLink(), nAGQ = 20, wts = ones(Float64, size(toenail, 1)));\nglmm2 = glmm(@formula(outcome ~ visit * treatment + (1|patientID)), toenail, Binomial(), LogitLink(), nAGQ = 20, wts = ones(Float64, size(toenail, 1)));\nanova(glmm1, glmm2)\n\nnote: Note\nOnly likelihood-ratio test is available now for GeneralizedLinearMixedModel.","category":"section"},{"location":"Examples_FixedEffectModels/#AnovaFixedEffectModels","page":"AnovaFixedEffectModels","title":"AnovaFixedEffectModels","text":"using AnovaFixedEffectModels\n\nAnovaFixedEffectModels.jl supports FixedEffectModels. \n\nlfe is as same as reg, but the order of arguments is closer to other modeling packages.\n\nfem1 = lfe(@formula(gpa ~ fe(student) + occasion + job), gpa)\naovf = anova(fem1)\n\nComparing between FixedEffectModelss and LinearModel is also available.\n\nfems = nestedmodels(FixedEffectModel, @formula(gpa ~ fe(student) + occasion + job), gpa)\naovf = anova(fems)\n\nIn this case, LinearModel has to be the simplest model.\n\naovf = anova(lm(@formula(gpa ~ occasion + job), gpa), lfe(@formula(gpa ~ fe(student) + occasion + job), gpa))\n\nLikelihood-ratio test is available for nested models.\n\nfems = nestedmodels(FixedEffectModel, @formula(gpa ~ fe(student) + occasion + job), gpa)\nanova(LRT, fems)","category":"section"},{"location":"Interface/#Interfacing-AnovaBase.jl","page":"Interfacing AnovaBase.jl","title":"Interfacing AnovaBase.jl","text":"Given model types SomeModel and OtherModel, the following functions have to be defined or used.","category":"section"},{"location":"Interface/#[anova](./AnovaBase.md#AnovaBase.anova-Tuple{Type{:GoodnessOfFit},%20AnovaModel})","page":"Interfacing AnovaBase.jl","title":"anova","text":"anova can be overloaded in the following arguments signature.\n\nanova(::SomeModel; test, type, kwargs...) \nanova(::GoodnessOfFit, ::SomeModel; type, kwargs...)\nanova(::Vararg{SomeModel}; test, kwargs...)\nanova(::GoodnessOfFit, ::Vararg{SomeModel}; kwargs...)\n\nOther arguments signatures are acceptable, but there will be Type piracy warnings.\n\nModels should be wrapped in the following types before storing in the returned AnovaResult.\n\nModel Wrapper\nSingle model FullModel\nNested models NestedModels\nNested models with different types MixedAovModels\n\nIt is recommended that anova additionally dispatched on wrapper types and the main algorithm is implemented in it.","category":"section"},{"location":"Interface/#[predictors](./AnovaBase.md#AnovaBase.predictors-Tuple{RegressionModel})","page":"Interfacing AnovaBase.jl","title":"predictors","text":"This function returns a tuple of terms which can be used in ANOVA (some terms may not be used because of ANOVA type or model itself).\n\nThere is a default method for RegressionModel, i.e., formula_aov(model).rhs.terms. If the formula for SomeModel has special structure like MixedModel, this function or formula_aov should be overloaded. ","category":"section"},{"location":"Interface/#AnovaModels","page":"Interfacing AnovaBase.jl","title":"AnovaModels","text":"","category":"section"},{"location":"Interface/#[NestedModels](./AnovaBase.md#AnovaBase.NestedModels)","page":"Interfacing AnovaBase.jl","title":"NestedModels","text":"Wrap nested models in the following way\n\nNestedModels{SomeModel}((model1, model2, ...))\nNestedModels{SomeModel}(model1, model2, ...)","category":"section"},{"location":"Interface/#[MixedAovModels](./AnovaBase.md#AnovaBase.MixedAovModels)","page":"Interfacing AnovaBase.jl","title":"MixedAovModels","text":"This is for comparing models with different types.\n\nMixedAovModels{Union{SomeModel, OtherModel}}((model1, model2, ...))\nMixedAovModels{Union{SomeModel, OtherModel}}(model1, model2, ...)\n\nBoth NestedModels and MixedAovModels do not check if the order is correct, so user should be careful to put simpler models former and more complex models later. ANOVA can be computed along with some basic statistics. See ftest_nested and lrt_nested.","category":"section"},{"location":"Interface/#[FullModel](./AnovaBase.md#AnovaBase.FullModel)","page":"Interfacing AnovaBase.jl","title":"FullModel","text":"FullModel wraps the model along with the index of predictors(pred_id) that is actually used in ANOVA and ANOVA type.\n\nAnovaBase provides a method which automatically determines pred_id based on ANOVA type, whether empty model is allowed, and whether intercept is tested. See FullModel.\n\nTo customize FullModel, there are many helper functions for manipulating terms. See Developer utility","category":"section"},{"location":"Interface/#[anovatable](./AnovaBase.md#AnovaBase.anovatable-Tuple{AnovaResult{:FullModel}})","page":"Interfacing AnovaBase.jl","title":"anovatable","text":"This function returns a AnovaTable for showing AnovaResult. For NestedModels and MixedAovModels, AnovaBase provides a default interface. When dealing with FullModel or customizing methods on SomeModel, the following methods should be defined.\n\nanovatable(::AnovaResult{<: FullModel{SomeModel}}; rownames)\nanovatable(::AnovaResult{<: NestedModels{SomeModel}}; rownames)\nanovatable(::AnovaResult{<: MixedAovModels{SomeModel}}; rownames)\n\nSee AnovaTable for the argument signature.","category":"section"},{"location":"Interface/#[nestedmodels](./AnovaBase.md#AnovaBase.nestedmodels-Tuple{RegressionModel})","page":"Interfacing AnovaBase.jl","title":"nestedmodels","text":"This function is not essential for ANOVA; it is just for convenience to create nested models(NestedModels). It should be defined as follow\n\nnestedmodels(SomeModel, ::FormulaTerm, data; kwargs)\nnestedmodels(::SomeModel; kwargs)\n\nAnovaBase provides a lot of functions to work on formula, terms and contrasts. See Developer utility","category":"section"},{"location":"Interface/#Other-function","page":"Interfacing AnovaBase.jl","title":"Other function","text":"dof_aovres calls dof_residual by default. If dof_residual(::SomeModel) is not valid for ANOVA, customize dof_aovres(::SomeModel). This function is utilized in the following function [dof_residual].\ndof_residual applies dof_aovres to all models by default. This function is utilized in the anovatable. \ndof_aov calls dof by default. If dof(::SomeModel) is not valid for ANOVA, customize dof_aov(::SomeModel). Currently, no other function depends on this function.\nformula_aov calls formula by default. If formula(::SomeModel) is not valid for ANOVA, customize formula_aov(::SomeModel). Several functions including predictors, and show function for ANOVA depend on this function. ","category":"section"},{"location":"AnovaMixedModels/#AnovaMixedModels.jl","page":"AnovaMixedModels.jl","title":"AnovaMixedModels.jl","text":"","category":"section"},{"location":"AnovaMixedModels/#AnovaBase.anova-Tuple{Type{<:GoodnessOfFit}, MixedModel}","page":"AnovaMixedModels.jl","title":"AnovaBase.anova","text":"anova(mixedmodels...; test::Type{<: GoodnessOfFit}, keyword_arguments...)\nanova(anovamodel; test::Type{<: GoodnessOfFit}, keyword_arguments...)\nanova(test::Type{<: GoodnessOfFit}, mixedmodels...; keyword_arguments...)\nanova(test::Type{<: GoodnessOfFit}, anovamodel; keyword_arguments...)\n\nAnalysis of variance.\n\nReturn AnovaResult{M, test, N}. See AnovaResult for details.\n\nArguments\n\nmixedmodels: model objects\nLinearMixedModel fitted by MixedModels.lmm or fit(LinearMixedModel, ...)\nGeneralizedLinearMixedModel fitted by MixedModels.glmm or fit(GeneralizedLinearMixedModel, ...)\nIf mutiple models are provided, they should be nested and the last one is the most complex. The first model can also be the corresponding GLM object without random effects.\nanovamodel: wrapped model objects; FullModel, NestedModels, and MixedAovModels.\ntest: test statistics for goodness of fit. Available tests are LikelihoodRatioTest (LRT) and FTest. The default is based on the model type.\nLinearMixedModel: FTest for one model; LRT for nested models.\nGeneralizedLinearMixedModel: LRT for nested models.\nModels should not be fitted by REML for LRT. \n\nOther keyword arguments\n\nWhen one model is provided:  \ntype: type of anova (1, 2 or 3). Default value is 1.\nadjust_sigma: whether adjust σ to match that of linear mixed-effect model fitted by REML. The result will be slightly deviated from that of model fitted by REML.\nWhen multiple models are provided:  \ncheck: allows to check if models are nested. Defalut value is true. Some checkers are not implemented now.\n\nnote: Note\nFor fitting new models and conducting anova at the same time, see anova_lmm for LinearMixedModel.\n\nnote: Note\nThe result with adjust_sigma will be slightly deviated from that of model fitted directly by REML.\n\nnote: Note\nFor the computation of degrees of freedom, please see dof_residual_pred.\n\n\n\n\n\n","category":"method"},{"location":"AnovaMixedModels/#AnovaMixedModels.anova_lmm","page":"AnovaMixedModels.jl","title":"AnovaMixedModels.anova_lmm","text":"anova_lmm(f::FormulaTerm, tbl; test::Type{<: GoodnessOfFit} = FTest, keyword_arguments...)\n\nanova_lmm(test::Type{<: GoodnessOfFit}, f::FormulaTerm, tbl; keyword_arguments...)\n\nanova(test::Type{<: GoodnessOfFit}, ::Type{<: LinearMixedModel}, f::FormulaTerm, tbl; keyword_arguments...)\n\nANOVA for linear mixed-effect models.\n\nArguments\n\nf: a Formula.\ntbl: a Tables.jl compatible data.\ntest: GoodnessOfFit. The default is FTest.\n\nAnova keyword arguments\n\ntest: GoodnessOfFit. The default is FTest.\ntype: type of anova (1, 2 or 3). Default value is 1.\nadjust_sigma: whether adjust σ to match that of linear mixed-effect model fitted by REML. The result will be slightly deviated from that of model fitted by REML.\n\nModel keyword arguments\n\nwts = []\ncontrasts = Dict{Symbol,Any}()\nprogress::Bool = true\nREML::Bool = true\n\nOther keyword arguments\n\nFor LRT, NestedModels is generated with the leftover keyword arguments using nestedmodels. For FTest, no other keyword arguments can be accepted.\n\nanova_lmm generate a LinearMixedModel fitted with REML if applying FTest; otherwise, a model fitted with ML.\n\nnote: Note\nThe result with adjust_sigma will be slightly deviated from that of model fitted directly by REML.\n\n\n\n\n\n","category":"function"},{"location":"AnovaMixedModels/#AnovaBase.nestedmodels-Tuple{LinearMixedModel}","page":"AnovaMixedModels.jl","title":"AnovaBase.nestedmodels","text":"nestedmodels(model::LinearMixedModel; null::Bool = true, keyword_arguments...)\n\nnestedmodels(::Type{LinearMixedModel}, f::FormulaTerm, tbl; null::Bool = true, wts = [], contrasts = Dict{Symbol, Any}(), verbose::Bool = false, REML::Bool = false)\n\nGenerate nested models from a model or modeltype, formula and data. The null model will be an empty model if the keyword argument null is true (default).\n\n\n\n\n\n","category":"method"},{"location":"AnovaMixedModels/#AnovaMixedModels.dof_residual_pred","page":"AnovaMixedModels.jl","title":"AnovaMixedModels.dof_residual_pred","text":"dof_residual_pred(model::LinearMixedModel)\ndof_residual_pred(aovm::FullModel{LinearMixedModel})\n\nCompute degrees of freedom (DOF) of residuals for each predictors in a linear mixed effect models.\n\nDOF of residuals are estimated by between-within method. For details, please refer to the documentation or GLMM FAQ for details.\n\nTo be noticed, my implementation is a little different from the reference one.  When intercept is not in fix effects, the reference algorithm regards the first term as intercept; however, there is no such replacement here. \n\n\n\n\n\n","category":"function"},{"location":"Examples_GLM/#AnovaGLM","page":"AnovaGLM","title":"AnovaGLM","text":"To use anova on GLM objects , we need AnovaGLM.jl.\n\nusing AnovaGLM\n\nThis function will export all functions from GLM and related function in this package, including anova, anova_lm, anova_glm.","category":"section"},{"location":"Examples_GLM/#Ordinary-linear-model","page":"AnovaGLM","title":"Ordinary linear model","text":"We first import the well-known iris dataset from RDatasets.\n\niris = dataset(\"datasets\", \"iris\")\n\nThere's two way to perform ANOVA. anova_lm accepts a formula and data like GLM.lm.\n\nanova_lm(@formula(SepalLength ~ SepalWidth + PetalLength + PetalWidth + Species), iris)\n\nWe can specify the type of sum of squares by keyword argument type. Let's use type II SS.\n\nanova_lm(@formula(SepalLength ~ SepalWidth + PetalLength + PetalWidth + Species), iris; type = 2)\n\nA StatsModels.TableRegressionModel object is fitted and stored in the output of anova_lm.  \n\nWe can fit a model first and call anova instead. anova stores the model as well.\n\nwarn: Warn\nIt doesn't create a copy, so any in-place change of the original model should be noticed. \n\nlm1 = lm(@formula(SepalLength ~ SepalWidth + PetalLength + PetalWidth + Species), iris)\nanova(lm1; type = 3)\n\nMultiple models can be compared through the same function.  \n\nnote: Note\nThe checker for nested models is not implemented now, so it should be ensured that the later model is more complex than the previous one.  \n\nlms = nestedmodels(LinearModel, @formula(SepalLength ~ SepalWidth * Species), iris; dropcollinear = false)\nanova(lms)\n\nThis result is a little bit different from GLM.ftest:\n\nftest(getproperty.(lms.model[2:end], :model)...)\n\nIn anova, the F value is calculated by dividing MSR (mean of ΔDeviance) with mean of RSS of the most complex model just like anova in R, while in GLM.ftest, the denominator is replaced by RSS of subsequent model.","category":"section"},{"location":"Examples_GLM/#Generalized-linear-models","page":"AnovaGLM","title":"Generalized linear models","text":"quine = dataset(\"MASS\", \"quine\")\n\nWe fit a negative binomial regression on quine dataset from MASS.\n\nnbm = glm(@formula(Days ~ Eth + Sex + Age + Lrn), quine, NegativeBinomial(2.0), LogLink())\nanova(nbm)\n\nThere's also anova_glm similar to anova_lm.  \n\nanova will automatically select test from F-test or likelihood-ratio test depending on the type of distribution. For distribution of Bernoulli(), Binomial(), Poisson() that have fixed dispersion, likelihood-ratio test is preferred. For other distribution, F-test is preferred. \n\nWe can specify test by keyword arguments test or putting test in the first argument.\n\nanova(nbm; test = FTest) # == anova(FTest, nbm)\n\nThe next one is an axample of logistic regression.\n\nmtcars = dataset(\"datasets\", \"mtcars\")\n\nWe want to predict if the AM is 0 or 1. Let's use logistic regression with and without interaction terms, and compare this two models by likelihood-ratio test. \n\nglm1 = glm(@formula(AM ~ Cyl + HP + WT), mtcars, Binomial(), LogitLink())\nglm2 = glm(@formula(AM ~ Cyl * HP * WT), mtcars, Binomial(), LogitLink())\nanova(glm1, glm2) # == anova(LRT, glm1, glm2)\n\nlrtest(glm1, glm2)\n\nThis function works identically as StatsModels.lrtest.","category":"section"},{"location":"AnovaGLM/#AnovaGLM.jl","page":"AnovaGLM.jl","title":"AnovaGLM.jl","text":"","category":"section"},{"location":"AnovaGLM/#AnovaBase.anova-Tuple{Type{<:GoodnessOfFit}, Vararg{StatsModels.TableRegressionModel{<:Union{GeneralizedLinearModel, LinearModel}}}}","page":"AnovaGLM.jl","title":"AnovaBase.anova","text":"anova(glmmodels...; test::Type{<: GoodnessOfFit}, keyword_arguments...)\nanova(anovamodel; test::Type{<: GoodnessOfFit}, keyword_arguments...)\nanova(test::Type{<: GoodnessOfFit}, glmmodels...; keyword_arguments...)\nanova(test::Type{<: GoodnessOfFit}, anovamodel; keyword_arguments...)\n\nAnalysis of variance.\n\nReturn AnovaResult{M, test, N}. See AnovaResult for details.\n\nArguments\n\nglmmodels: model objects\nTableRegressionModel{<: LinearModel} fitted by GLM.lm\nTableRegressionModel{<: GeneralizedLinearModel} fitted by GLM.glm\nIf mutiple models are provided, they should be nested and the last one is the most complex.\nanovamodel: wrapped model objects; FullModel and NestedModels.\ntest: test statistics for goodness of fit. Available tests are LikelihoodRatioTest (LRT) and FTest. The default is based on the model type.\nTableRegressionModel{<: LinearModel}: FTest.\nTableRegressionModel{<: GeneralizedLinearModel}: based on distribution function, see canonicalgoodnessoffit.\n\nOther keyword arguments\n\nWhen one model is provided:  \ntype specifies type of anova (1, 2 or 3). Default value is 1.\nWhen multiple models are provided:  \ncheck: allows to check if models are nested. Defalut value is true. Some checkers are not implemented now.\n\nnote: Note\nFor fitting new models and conducting anova at the same time, see anova_lm for LinearModel, anova_glm for GeneralizedLinearModel.\n\n\n\n\n\n","category":"method"},{"location":"AnovaGLM/#AnovaGLM.anova_lm","page":"AnovaGLM.jl","title":"AnovaGLM.anova_lm","text":"anova_lm(X, y; test::Type{<: GoodnessOfFit} = FTest, keyword_arguments...) \n\nanova_lm(test::Type{<: GoodnessOfFit}, X, y; keyword_arguments...)\n\nanova(test::Type{<: GoodnessOfFit}, ::Type{LinearModel}, X, y; \n    type::Int = 1, \n    keyword_arguments...)\n\nANOVA for simple linear regression.\n\nArguments\n\nX and y can be a Matrix and a Vector or a Formula and a Tables.jl compatible data. \ntest: test statistics for goodness of fit.\n\nKeyword arguments\n\ntest: test statistics for goodness of fit.\ntype specifies type of anova (1, 2 or 3). Default value is 1.\ndropcollinear controls whether or not lm accepts a model matrix which is less-than-full rank. If true (the default), only the first of each set of linearly-dependent columns is used. The coefficient for redundant linearly dependent columns is 0.0 and all associated statistics are set to NaN.\n\nanova_lm generate a TableRegressionModel object, which is fitted by lm.\n\n\n\n\n\n","category":"function"},{"location":"AnovaGLM/#AnovaGLM.anova_glm","page":"AnovaGLM.jl","title":"AnovaGLM.anova_glm","text":"anova_glm(X, y, d::UnivariateDistribution, l::Link = canonicallink(d); \n        test::Type{<: GoodnessOfFit} = canonicalgoodnessoffit(d), keyword_arguments...)\n\nanova_glm(test::Type{<: GoodnessOfFit}, X, y, d::UnivariateDistribution, l::Link = canonicallink(d); keyword_arguments...)\n\nanova(test::Type{<: GoodnessOfFit}, X, y, d::UnivariateDistribution, l::Link = canonicallink(d); keyword_arguments...)\n\nANOVA for genaralized linear models.\n\nArguments\n\nX and y can be a Matrix and a Vector or a Formula and a Tables.jl compatible data.\nd: a GLM.UnivariateDistribution.\nl: a GLM.Link\ntest: test statistics for goodness of fit based on distribution function. See canonicalgoodnessoffit.\n\nFor other keyword arguments, see fit.\n\n\n\n\n\n","category":"function"},{"location":"AnovaGLM/#AnovaBase.nestedmodels-Tuple{StatsModels.TableRegressionModel{<:LinearModel}}","page":"AnovaGLM.jl","title":"AnovaBase.nestedmodels","text":"nestedmodels(trm::TableRegressionModel{<: LinearModel}; null::Bool = true, keyword_arguments...)\nnestedmodels(trm::TableRegressionModel{<: GeneralizedLinearModel}; null::Bool = true, keyword_arguments...)\n\nnestedmodels(::Type{LinearModel}, formula, data; null::Bool = true, keyword_arguments...)\nnestedmodels(::Type{GeneralizedLinearModel}, formula, data, distr::UnivariateDistribution, link::Link = canonicallink(d); null::Bool = true, keyword_arguments...)\n\nGenerate nested nested models NestedModels from a model or formula and data.\n\nThe null model will be a model with at least one factor (including intercept) if the link function does not allow factors to be 0 (factors in denominators) or the keyword argument null is false (default value is true).\n\nInverseLink for Gamma\nInverseSquareLink for InverseGaussian\nLinearModel fitted with CholeskyPivoted when dropcollinear = true\n\nOtherwise, it will be an empty model.\n\n\n\n\n\n","category":"method"},{"location":"Algorithm_AnovaMixedModels/#AnovaMixedModels","page":"AnovaMixedModels","title":"AnovaMixedModels","text":"","category":"section"},{"location":"Algorithm_AnovaMixedModels/#F-test","page":"AnovaMixedModels","title":"F-test","text":"Given a model M, n is the number of predictors, m is the number of columns of M's model matrix.\n\nDefine two sets, mathcalC = x in mathbbN  1 leq x leq m, the index of columns and mathcalP = x in mathbbN  1 leq x leq n, the index of predictors.\n\nA map id_X mathcalC mapsto mathcalP maps the index of columns into the corresponding predictor sequentially, i.e.,\n\nbeginaligned\n    forall i in mathcalC id_X(i) = k implies itextth column text is a level of  ktextth predictor\n    forall i j in mathcalC i lt j implies id_X(i) leq id_X(j)\nendaligned\n\nWe can define a vector of index set for each predictors,\n\nbeginaligned\n    mathbfI = (I_1  I_n)\n    mathbfdf = (n(I_1)  n(I_n))\nendaligned\n\nwhere forall i in I_k id_X(i) = k, and n(I) is the size of I.\n\nF-value is a vector\n\nmathbfF sim mathcalF_mathbfdf mathbfdf_r\n\nwhere mathbfdf_r is estimated by between-within method.\n\nF-value is computed directly by the variance-covariance matrix (boldsymbol Sigma) and the coefficients (boldsymbol beta) of the model. ","category":"section"},{"location":"Algorithm_AnovaMixedModels/#Type-I","page":"AnovaMixedModels","title":"Type I","text":"Calculate F-value by the the upper factor of Cholesky factorization of boldsymbol Sigma^-1 and multiplying with boldsymbol beta\n\nbeginaligned\n    boldsymbolSigma^-1 = mathbfLU\n    boldsymboleta = mathbfUboldsymbolbeta\n    F_j = fracsum_k in I_jeta_k^2df_j\nendaligned","category":"section"},{"location":"Algorithm_AnovaMixedModels/#Type-II","page":"AnovaMixedModels","title":"Type II","text":"Define two vectors of index sets mathbf J and mathbf K where\n\nbeginaligned\n    J_j = i in mathcalC  id_X(i) text is an interaction term of jtextth predictor and other terms\n    K_j = J_j cup I_j\nendaligned\n\nAnd F-value is\n\nF_j = fracboldsymbolbeta_K_j^T boldsymbolSigma_K_j K_j^-1 boldsymbolbeta_K_j - boldsymbolbeta_J_j^T boldsymbolSigma_J_j J_j^-1 boldsymbolbeta_J_jdf_j","category":"section"},{"location":"Algorithm_AnovaMixedModels/#Type-III","page":"AnovaMixedModels","title":"Type III","text":"F_j = fracboldsymbolbeta_I_j^T boldsymbolSigma_I_j I_j^-1 boldsymbolbeta_I_jdf_j","category":"section"},{"location":"Algorithm_AnovaMixedModels/#LRT","page":"AnovaMixedModels","title":"LRT","text":"Given a vector of models\n\nmathbfM = (M_1  M_n)\n\nDefine the deviance mathbfD as -2loglikelihood of mathbfM and mathbfdm as the degrees of freedom of mathbfM, the likelihood ratio is a vector\n\nbeginaligned\n    mathbfL = mathbfD_1 n - 1 - mathbfD_2 n\n    mathbfdf = mathbfdm_1 n - 1 - mathbfdm_2 n\n    mathbfL sim chi^2_mathbfdf\nendaligned","category":"section"},{"location":"Algorithm_AnovaGLM/#AnovaGLM","page":"AnovaGLM","title":"AnovaGLM","text":"Define a vector of models mathbfM and the corresponding base models mathbfB\n\nbeginaligned\n    mathbfM = (M_1  M_n)\n    mathbfB = (B_1  B_n)\nendaligned\n\nwhere M_1 is the simplest model and M_n is the most complex model.\n\nWhen m models, (M_1  M_m), are given, mathbfM = (M_2  M_m), mathbfB = (M_1  M_m-1). \n\nWhen one model is given, n is the number of predictors except for the predictors used in the simplest model. The mathbf M and mathbf B depends on the type of ANOVA.\n\nLet m, the number of columns of M_n's model matrix; l, the number of predictors of M_n. \n\nDefine two sets, mathcalC = x in mathbbN  1 leq x leq m, the index of columns and mathcalP = x in mathbbN  1 leq x leq l, the index of predictors.\n\nA map id_X mathcalC mapsto mathcalP maps the index of columns into the corresponding predictor sequentially, i.e., \n\nbeginaligned\n    forall i in mathcalC id_X(i) = k implies itextth column text is a level of  ktextth predictor\n    forall i j in mathcalC i lt j implies id_X(i) leq id_X(j)\nendaligned\n\nThe included predictors of M_j and B_j are mathcalM_j subset mathcalP,  mathcalB_j subset mathcalP, respectively.\n\nWe can define a vector of index sets for each model, and calulate degrees of freedom (dof) of each predictor\n\nbeginaligned\n    mathbfI = (I_1  I_n)\n    mathbfdf = (n(I_1)  n(I_n))\nendaligned\n\nwhere forall i in I_k id_X(i) in mathcalM_ksetminus mathcalB_k, and n(I) is the size of I.\n\nThe deviance vector mathbfD for mathbfM and mathbfS for mathbfB are  defined as the sum of squared deviance residuals (unit deviance) of each model.  It is equivalent to the residual sum of squares for ordinary linear regression.\n\nThe explained deviance of each predictor is the difference of mathbfD and mathbfS\n\nmathbfE = mathbfD - mathbfS\n\nThe mean explained deviance epsilon_i^2 is therefore\n\nepsilon_i^2 = fracE_idf_i\n\nThe mean residual deviance sigma^2 is the squred estimated dispersion (or scale) parameter for M_n's distribution.\n\nFor ordinary linear regression, \n\nsigma^2 =fracD_ndf_r\n\nwhere D_n is the residual sum of squares of M_n; df_r is the degrees of freedom of the residuals, i.e. df_r = nob - n(mathcalC), where nob is number of observations.","category":"section"},{"location":"Algorithm_AnovaGLM/#F-test","page":"AnovaGLM","title":"F-test","text":"F-value is a vector\n\nmathbfF sim mathcalF_mathbfdf df_r\n\nwhere \n\nF_i = fracepsilon_i^2sigma^2\n\nFor a single model, F-value is computed directly by the variance-covariance matrix (boldsymbol Sigma) and the coefficients (boldsymbol beta) of the most complex model, the deviance is calculated backward; each M_j corresponds to a predictor p_j, i.e. id_XI_j = j.","category":"section"},{"location":"Algorithm_AnovaGLM/#Type-I","page":"AnovaGLM","title":"Type I","text":"Predictors are sequentially added to the null model B_1, i.e., \n\nbeginaligned\n    forall i j in x in mathbbN  1leq xleq n i  j implies (mathcalB_i subset mathcalB_j) land (mathcalM_i subset mathcalM_j)\n    mathcalM_i = mathcalB_i cup p_i\n    mathcalB_i+1 = mathcalM_i\nendaligned\n\nCalculate F-value by the the upper factor of Cholesky factorization of boldsymbol Sigma^-1 and multiplying with boldsymbol beta\n\nbeginaligned\n    boldsymbolSigma^-1 = mathbfLU\n    boldsymboleta = mathbfUboldsymbolbeta\n    F_j = fracsum_k in I_jeta_k^2df_j\nendaligned","category":"section"},{"location":"Algorithm_AnovaGLM/#Type-II","page":"AnovaGLM","title":"Type II","text":"The included predictors are defined as follows,\n\nbeginaligned\n    mathcalB_j = k in mathcalP  k text is not an interaction term of p_j text and other terms\n    mathcalM_j = mathcalB_j cup p_j\nendaligned\n\nDefine two vectors of index sets mathbf J and mathbf K where \n\nbeginaligned\n    J_j = i in mathcalC  id_X(i) text is an interaction term of p_j text and other terms\n    K_j = J_j cup I_j\nendaligned\n\nAnd F-value is\n\nF_j = fracboldsymbolbeta_K_j^T boldsymbolSigma_K_j K_j^-1 boldsymbolbeta_K_j - boldsymbolbeta_J_j^T boldsymbolSigma_J_j J_j^-1 boldsymbolbeta_J_jdf_j","category":"section"},{"location":"Algorithm_AnovaGLM/#Type-III","page":"AnovaGLM","title":"Type III","text":"All elements of mathbfM are the most complex model, and the base models are models without each predictors, i.e.\n\nbeginaligned\n    mathcalM_j = mathcalP\n    mathcalB_j = mathcalP setminus p_j\nendaligned\n\nAnd F-value is\n\nF_j = fracboldsymbolbeta_I_j^T boldsymbolSigma_I_j I_j^-1 boldsymbolbeta_I_jdf_j","category":"section"},{"location":"Algorithm_AnovaGLM/#LRT","page":"AnovaGLM","title":"LRT","text":"The likelihood ratio is a vector\n\nbeginaligned \n    mathbfL = fracmathbfEsigma^2\n    mathbfL sim chi^2_mathbfdf\nendaligned\n\nWhen a single model is provided, mathbfL is computed directly by the variance-covariance matrix.\n\nCalculate likelihood ratio by the the upper factor of Cholesky factorization of sigma^2 boldsymbolSigma^-1 and multiplying with boldsymbol beta\n\nbeginaligned\n    sigma^2 boldsymbolSigma^-1 = mathbfLU\n    boldsymboleta = mathbfUboldsymbolbeta\n    L_j = sum_k in I_jeta_k^2\nendaligned","category":"section"},{"location":"#AnovaBase.jl-Documentation","page":"AnovaBase.jl Documentation","title":"AnovaBase.jl Documentation","text":"AnovaBase.jl is a Julia package providing a simple framework for Analysis of Varaincae (ANOVA) on various types of julia statistical models. It is similar to function anova in R.","category":"section"},{"location":"#Functionality-overview","page":"AnovaBase.jl Documentation","title":"Functionality overview","text":"","category":"section"},{"location":"#ANOVA","page":"AnovaBase.jl Documentation","title":"ANOVA","text":"anova(model; type, test)\nanova(test, model; type)\nanova(models; test)\nanova(test, models)","category":"section"},{"location":"#Model-specific-ANOVA","page":"AnovaBase.jl Documentation","title":"Model-specific ANOVA","text":"","category":"section"},{"location":"#AnovaGLM","page":"AnovaBase.jl Documentation","title":"AnovaGLM","text":"anova_lm(formula, data; type, test)\nanova_lm(test, formula, data; type)\nanova_glm(formula, data, distr, link; type, test)\nanova_glm(test, formula, data, distr, link; type)","category":"section"},{"location":"#AnovaMixedModels","page":"AnovaBase.jl Documentation","title":"AnovaMixedModels","text":"anova_lme(formula, data; type, test)\nanova_lme(test, formula, data; type)","category":"section"},{"location":"#AnovaFixedEffecModels","page":"AnovaBase.jl Documentation","title":"AnovaFixedEffecModels","text":"anova_lfe(formula, data, vcov; type, test)\nanova_lfe(test, formula, data, vcov; type)","category":"section"},{"location":"#nestedmodels","page":"AnovaBase.jl Documentation","title":"nestedmodels","text":"nestedmodels(modeltype, formula, data)\nnestedmodels(model)","category":"section"},{"location":"#Usage","page":"AnovaBase.jl Documentation","title":"Usage","text":"This package is not intentded to be used directly. Use the following packages for different models:\n\nPackages for models Packages for ANOVA Models Fitted by\nGLM.jl AnovaGLM.jl TableRegressionModel{<: LinearModel} GLM.lm or fit(LinearModel, _)\n  TableRegressionModel{<: GeneralizedLinearModel} GLM.glm or fit(GeneralizedLinearModel, _)\nMixedModels.jl AnovaMixedModels.jl LinearMixedModel AnovaMixedModels.lme or fit(LinearMixedModel, _)\n  GeneralizedLinearMixedModel AnovaGLM.glme or fit(GeneralizedLinearMixedModel, _)\nFixedEffectModels.jl AnovaFixedEffectModels.jl FixedEffectModel AnovaFixedEffectModels.lfe or FixedEffectModels.reg","category":"section"},{"location":"#Tests-for-Goodness-of-Fit","page":"AnovaBase.jl Documentation","title":"Tests for Goodness of Fit","text":"FTest: F-test\nLikelihoodRatioTest, LRT: likelihood-ratio test","category":"section"},{"location":"#Types-of-Estimable-Functions","page":"AnovaBase.jl Documentation","title":"Types of Estimable Functions","text":"Type I, II, III SS  are supported. ","category":"section"},{"location":"#Table-of-Contents","page":"AnovaBase.jl Documentation","title":"Table of Contents","text":"","category":"section"},{"location":"#Examples","page":"AnovaBase.jl Documentation","title":"Examples","text":"Pages = [\n    \"Examples_GLM.md\",\n    \"Examples_MixedModels.md\",\n    \"Examples_FixedEffectModels.md\"\n]\nDepth = 2","category":"section"},{"location":"#Algorithm","page":"AnovaBase.jl Documentation","title":"Algorithm","text":"Pages = [\n    \"Algorithm_AnovaGLM.md\",\n    \"Algorithm_AnovaMixedModels.md\",\n    \"Algorithm_AnovaFixedEffectModels.md\"\n]\nDepth = 2","category":"section"},{"location":"#Interfacing-AnovaBase.jl","page":"AnovaBase.jl Documentation","title":"Interfacing AnovaBase.jl","text":"Pages = [\"Interface.md\"]\nDepth = 2","category":"section"},{"location":"#API","page":"AnovaBase.jl Documentation","title":"API","text":"Pages = [\n    \"AnovaBase.md\",\n    \"AnovaGLM.md\",\n    \"AnovaMixedModels.md\",\n    \"AnovaFixedEffectModels.md\"\n]","category":"section"}]
}
